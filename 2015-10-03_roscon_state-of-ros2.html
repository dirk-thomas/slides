<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>State of ROS 2 - Demos and the technology behind</title>

    <meta name="description" content="Description of the current state of ROS 2 at ROSCon 2015">
    <meta name="author" content="Dirk Thomas">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/bootstrap-3.3.5.css">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/default.css">

    <link rel="stylesheet" href="css/osrf.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <div class="osrf-signature">
          <svg id="osrf-logo" height="1.8em" width="1.8em" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
            <image id="osrf-logo-image" x="0" y="0" height="100%" width="100%" xlink:href="image/osrf-logo.svg"/>
            <animateTransform id="osrf-logo-clockwise" xlink:href="#osrf-logo-image" attributeName="transform" attributeType="XML"
              type="rotate" from="0 27 27" to="360 27 27" dur="0.7s" calcMode="spline" keySplines="0.5 0 0.5 1" keyTimes="0;1" begin="indefinite" repeatCount="0" fill="freeze"/>
            <animateTransform id="osrf-logo-counterclockwise" xlink:href="#osrf-logo-image" attributeName="transform" attributeType="XML"
              type="rotate" from="360 27 27" to="0 27 27" dur="0.7s" calcMode="spline" keySplines="0.5 0 0.5 1" keyTimes="0;1" begin="indefinite" repeatCount="0" fill="freeze"/>
            <animate id="osrf-logo-flash" attributeType="CSS" attributeName="opacity"
              dur="0.7s" values="1; 0.25; 1" keyTimes="0; 0.25; 1" repeatCount="0" />
          </svg>
          <svg id="osrf-lettering" height="1.4em" width="32%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
            <image x="0" y="0" height="75%" width="100%" xlink:href="image/osrf-lettering.svg"/>
          </svg>
        </div>

        <section>
          <h1>State of ROS 2</h1>
          <h3>Demos and the technology behind</h3>
          <p>
            <small>
              Oct. 3rd 2015<br/>
              Dirk Thomas, Esteve Fernandez, William Woodall<br/>
              ROSCon 2015, Hamburg, Germany
            </small>
          </p>
        </section>

        <section>
          <h2>Goals of ROS 2</h2>
          <div class="row">
            <div class="col-md-5 col-md-offset-1" style="height: 9em;">
              <img src="image/multi-robot-systems.png" class="center-block" height="60%" alt=""/>
              <small>Support multi-robot systems<br/>
              involving unreliable networks</small>
            </div>
            <div class="col-md-5" style="height: 9em;">
              <img src="image/bosch-lawnmower.png" class="center-block" height="60%" alt=""/>
              <small>Remove the gap between<br/>
              prototyping and final products</small>
            </div>
          </div>
          <div class="row">
            <div class="col-md-4" style="height: 9em;">
              <img src="image/micro-controller.png" class="center-block" height="60%" alt=""/>
              <small><i>&ldquo;Bare-metal&rdquo;</i><br/>
              micro controller</small>
            </div>
            <div class="col-md-4" style="height: 9em;">
              <img src="image/robonaut2.png" class="center-block" height="60%" alt=""/>
              <small>Support for<br/>
              real-time control</small>
            </div>
            <div class="col-md-4" style="height: 9em;">
              <img src="image/linux-windows-osx.png" class="center-block" height="60%" alt=""/>
              <small>Cross-platform<br/>
              support</small>
            </div>
          </div>

          <aside class="notes">
            End time: 1:15
          </aside>
        </section>

        <section data-markdown data-separator-notes="^Note:">
          <script type="text/template">
            ## Outline

            - Walk through multiple demos
              * https://github.com/ros2/ros2/wiki/Tutorials

            - Technical background information

            Note:
            All following demos build and run on the three platforms.

            End time: 1:30
          </script>
        </section>

        <section>
          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              ## Publish / Subscribe Demo

              Note:
              Run the following commands:
              - Shell A: `. ros2_ws/install/setup.bash`, `export OSPL_VERBOSITY=3`, `talker__rmw_opensplice_cpp` publishing messages
              - Shell B: `. ros2_ws/install/setup.bash`, `listener__rmw_connext_cpp` subscribing to messages

              End time: 2:00
            </script>
          </section>

          <section>
            <h2>Publish / Subscribe</h2>
            <br/>
            <br/>
            <svg id="publish-subscribe" width="860" height="330">
              <marker id="publish-subscribe_end-triangle" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="10" markerHeight="7" orient="auto">
                <path d="M 0 0 L 10 5 L 0 10 z"/>
              </marker>
              <marker id="publish-subscribe_end-triangle-red" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="10" markerHeight="7" orient="auto">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#c7254e"/>
              </marker>
              <line x1="50%" y1="0" x2="50%" y2="70%" style="stroke: #cccccc;" stroke-dasharray="5,5"/>
              <g title="Publisher">
                <rect x="10" y="10" width="330" height="40"/>
                <text x="175" y="40" text-anchor="middle">talker</text>
              </g>
              <g title="Subscriber">
                <rect x="520" y="10" width="330" height="40"/>
                <text x="685" y="40" text-anchor="middle">listener</text>
              </g>
              <g title="rclcpp" class="fragment">
                <rect x="10" y="60" width="330" height="40"/>
                <text x="175" y="90" text-anchor="middle">rclcpp</text>
                <rect x="520" y="60" width="330" height="40"/>
                <text x="685" y="90" text-anchor="middle">rclcpp</text>
              </g>
              <g title="rmw interface" class="fragment">
                <rect x="10" y="110" width="330" height="40"/>
                <text x="175" y="140" text-anchor="middle">rmw interface</text>
                <rect x="520" y="110" width="330" height="40"/>
                <text x="685" y="140" text-anchor="middle">rmw interface</text>
              </g>
              <g title="rmw" class="fragment">
                <g style="opacity: 0.5">
                  <rect x="10" y="160" width="160" height="40"/>
                  <text x="90" y="190" text-anchor="middle">Connext</text>
                </g>
                <rect x="180" y="160" width="160" height="40"/>
                <text x="260" y="190" text-anchor="middle">OpenSplice</text>
                <rect x="520" y="160" width="160" height="40"/>
                <text x="600" y="190" text-anchor="middle">Connext</text>
                <g style="opacity: 0.5">
                  <rect x="690" y="160" width="160" height="40"/>
                  <text x="770" y="190" text-anchor="middle">OpenSplice</text>
                </g>
              </g>
              <g title="choose-rmw-impl" class="fragment current-visible">
                <line x1="320" y1="250" x2="260" y2="200" style="stroke: #c7254e;" marker-end="url(#publish-subscribe_end-triangle-red)"/>
                <line x1="540" y1="250" x2="600" y2="200" style="stroke: #c7254e;" marker-end="url(#publish-subscribe_end-triangle-red)"/>
                <text x="50%" y="280" text-anchor="middle" style="fill: #c7254e; stroke: #c7254e;">selected at link-time</text>
                <text x="50%" y="320" text-anchor="middle" style="fill: #c7254e; stroke: #c7254e;">of the executables</text>
              </g>
              <g title="network" class="fragment">
                <polyline points="260,200 260,250 600,250 600,200" marker-end="url(#publish-subscribe_end-triangle)"/>
                <text x="50%" y="300" text-anchor="middle">DDS Interoperability Wire Protocol</text>
              </g>
            </svg>

            <aside class="notes">
              <ul>
                <li>No need to run a central <code>roscore</code></li>
                <li>RTPS protocol</li>
              </ul>
              End time: 3:00
            </aside>
          </section>

          <section data-transition="slide-in fade-out">
            <h2>Source code of the <i>listener</i> (ROS 1)</h2>
            <pre><code class="cpp" data-trim>
void callback(const std_msgs::String::ConstPtr & msg)
{
  ROS_INFO("I heard: [%s]", msg->data.c_str());
}

int main(int argc, char * argv[])
{
  ros::init(argc, argv, "listener");

  ros::NodeHandle node;

  ros::Subscriber sub = node.subscribe("chatter", 10, callback);

  ros::spin();

  return 0;
}
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
            </code></pre>
          </section>

         <section data-transition="fade-in">
           <h2>Source code of the <i>listener</i> (ROS 1)</h2>
           <pre><code class="cpp" data-trim>
// void callback(const std_msgs::String::ConstPtr & msg)

{
  // ROS_INFO("I heard: [%s]", msg->data.c_str());

}

int main(int argc, char * argv[])
{
  // ros::init(argc, argv, "listener");


  // ros::NodeHandle node;


  // ros::Subscriber sub = node.subscribe("chatter", 10, callback);



  // ros::spin();


  return 0;
}
            </code></pre>
          </section>

          <section data-transition="fade-in slide-out">
            <h2>Source code of the <i>listener (ROS 2)</i></h2>
            <pre><code class="cpp" data-trim>
// void callback(const std_msgs::String::ConstPtr & msg)
void callback(std_msgs::msg::String::ConstSharedPtr msg)
{
  // ROS_INFO("I heard: [%s]", msg->data.c_str());
  printf("I heard: [%s]\n", msg->data.c_str());
}

int main(int argc, char * argv[])
{
  // ros::init(argc, argv, "listener");
  rclcpp::init(argc, argv);

  // ros::NodeHandle node;
  auto node = rclcpp::Node::make_shared("listener");

  // ros::Subscriber sub = node.subscribe("chatter", 10, callback);
  auto sub = node->create_subscription&lt;std_msgs::msg::String>(
    "chatter", rmw_qos_profile_default, callback);

  // ros::spin();
  rclcpp::spin(node);

  return 0;
}
            </code></pre>

            <p style="position: absolute; top: 72%; right: 8%; width: 50%; border: 3px solid #353535; color: #2a76dd;" class="fragment fade-out" data-fragment-index="1">
              C++11 wherever it makes it easier,<br/>the callback can be a lambda.
            </p>
            <svg id="c++11-highlight" width="100%" height="100%" style="position: absolute; top: 0; left: 0; fill: none;" class="fragment fade-out" data-fragment-index="1">
              <line x1="21%" y1="24%" x2="59.5%" y2="24%" style="stroke: #2a76dd;"/>
              <line x1="8.5%" y1="60.5%" x2="13%" y2="60.5%" style="stroke: #2a76dd;"/>
              <line x1="8.5%" y1="69.7%" x2="13%" y2="69.7%" style="stroke: #2a76dd;"/>
              <line x1="48%" y1="72.8%" x2="57%" y2="72.8%" style="stroke: #2a76dd;" stroke-dasharray="5,5"/>
            </svg>

            <p style="position: absolute; top: 33%; right: 8%; width: 43%; border: 3px solid #353535; color: #2a76dd;" class="fragment current-visible" data-fragment-index="1">
              The node's name is passed<br/>to the node constructor,<br/>not the global init() function.
            </p>
            <svg id="node-name-highlight" width="100%" height="100%" style="position: absolute; top: 0; left: 0; fill: none;" class="fragment current-visible" data-fragment-index="1">
              <marker id="node-name_end-triangle-blue" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="10" markerHeight="7" orient="auto">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#2a76dd"/>
              </marker>
              <line x1="40%" y1="48.5%" x2="48%" y2="57.5%" style="stroke: #2a76dd;" marker-end="url(#node-name_end-triangle-blue)"/>
            </svg>

            <p style="position: absolute; top: 72%; right: 20%; width: 40%; border: 3px solid #353535; color: #2a76dd;" class="fragment current-visible" data-fragment-index="2">
              The subscriber is templated on the message type.
            </p>
            <svg id="templated-subscriber-highlight" width="100%" height="100%" style="position: absolute; top: 0; left: 0; fill: none;" class="fragment current-visible" data-fragment-index="2">
              <line x1="46%" y1="69.7%" x2="70%" y2="69.7%" style="stroke: #2a76dd;"/>
            </svg>

            <p style="position: absolute; top: 72%; right: 30%; width: 40%; border: 3px solid #353535; color: #2a76dd;" class="fragment current-visible" data-fragment-index="3">
              <code>spin()</code> is called <i>on</i> the node,<br/>not globally.
            </p>
            <svg id="spin-highlight" width="100%" height="100%" style="position: absolute; top: 0; left: 0; fill: none;" class="fragment current-visible" data-fragment-index="3">
              <line x1="8.5%" y1="82%" x2="27%" y2="82%" style="stroke: #2a76dd;"/>
            </svg>

            <aside class="notes">
              <ul>
                <li><code>std</code> instead of <code>boost</code></li>
                <li><code>rmw_qos_profile_default</code> mentioned later</li>
                <li><code>spin</code> is the simplest threading model</li>
              </ul>
              <br/>
              End time: 4:30
            </aside>
          </section>

          <section>
            <h2>DDS vendors</h2>

            <table border="1" rules="all" frame="void">
              <tr>
                <th colspan="2">Company and<br/>product name</th>
                <th><br/>License</th>
                <th>RMW<br/>impl.</th>
                <th><br/>Comments</th>
              </tr>
              <tr>
                <td><img src="image/rti.png" width="60" style="margin: 0.3em 0; vertical-align: top;" alt=""/></td>
                <td>RTI<br/>Connext</td>
                <td>commercial,<br/>research</td>
                <td align="center"><span class="glyphicon glyphicon-ok"></span></td>
                <td>stat. &amp; dyn. impl.</td>
              </tr>
              <tr>
                <td><img src="image/prismtech.png" width="60" style="margin: 0.3em 0; vertical-align: top;" alt=""/></td>
                <td>PrismTech<br/>OpenSplice</td>
                <td>commercial,<br/>LGPL</td>
                <td align="center"><span class="glyphicon glyphicon-ok"></span></td>
                <td>only version 6.4 is LGPL</td>
              </tr>
              <tr>
                <td><img src="image/twinoaks.png" width="60" style="margin: 0.3em 0; vertical-align: top;" alt=""/></td>
                <td>TwinOaks<br/>CoreDX</td>
                <td>commercial</td>
                <td align="center"><span class="glyphicon glyphicon-minus"></span></td>
                <td></td>
              </tr>
              <tr>
                <td><img src="image/eprosima.png" width="60" style="margin: 0.3em 0; vertical-align: top;" alt=""/></td>
                <td>eProsima<br/>FastRTPS</td>
                <td>LGPL</td>
                <td align="center"><span class="glyphicon glyphicon-ok"></span></td>
                <td>no support for<br/>fragmentation yet</td>
              </tr>
              <tr>
                <td><img src="image/osrf-logo.svg" width="60" style="margin: 0.3em 0; vertical-align: top;" alt=""/></td>
                <td>OSRF<br/>FreeRTPS</td>
                <td>Apache 2</td>
                <td align="center"><b style="font-size: 0.8em">partial</b></td>
                <td>small part of DDS only<br/>aiming for emb. devices</td>
              </tr>
            </table>

            <aside class="notes">
              End time: 6:30
            </aside>
          </section>
        </section>

        <section>
          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # Transparent Intra-Process Communications

              Why support transparent intra-process communications?
              - Provide performance improvements for:
                - Node which communicates to itself (loop back within a node).
                - Node which communicates with other nodes in the same process.
              - It achieves performance improvements by:
                - Avoiding serialization and deserialization of messages.
                - Avoiding unnecessary copying.
                - Avoiding the network stack and packetization.

              Note:
              10 minutes for these slide.
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # ROS 1
              ## Already Does a Pretty Good Job

              Intra-process communication:

              - Avoids serialization and deserialization.
              - Avoids the network stack (TCP so no userspace packetization).
              - Avoids copies, though in an unsafe way:

              <p style="font-size: small; margin-left: 50px">From: http://wiki.ros.org/roscpp/Overview/Publishers%20and%20Subscribers#Intraprocess_Publishing</p>
              <pre>
              Note that when publishing in this fashion, there is an implicit contract between you and roscpp: you may not modify the message you&#39;ve sent after you send it, since that pointer will be passed directly to any intra-process subscribers. If you want to send another message, you must allocate a new one and send that.
              </pre>

              Note:

            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # ROS 2
              ## Will Make Improvements

              Intra-process communication:

              - Avoids serialization and deserialization.
              - Avoids the network stack and packetizing of data.
              - Avoid copies safely by providing `unique_ptr` based APIs.
              - Avoid copies when publishing and subscribing to user-defined types.

              Note:
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # Hidden Issues in ROS 1

              Consider the case of publishing a `shared_ptr` of a message:

              ```c++
              std::shared_ptr<std_msgs::msg::String> msg(new std_msgs::msg::String());

              msg->data = "testing";
              publisher->publish(msg);
              // The user still has ownership at this point, could do something like this:
              msg->data = "testing2";
              ```

              Will the subscribing callbacks get `"testing"` or `"testing2"`?

               - They will get `"testing"` because `publish(...)` actually calls the intra-process callbacks directly.
               - Unless they store it and check it later, in which case it might be `"testing2"`.

              What happens if the subscriber callbacks run long?

              Note:
              - If the callbacks are long then publish becomes unexpected blocking. This differs from the behavior in inter process publish.
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # Safely do Intra-Process

              These issues in the current approach cause large differences in intra-process and inter process behavior.
              How do we solve this?

              *By tracking ownership with ownership semantics, i.e. `unique_ptr`*

              Now consider how a `unique_ptr` works:

              ```c++
              std::unique_ptr<A> a, b;
              a.reset(new A());
              // a is valid.
              // b is a nullptr.
              b = a;  // Ownership of the pointer returned by `new A()` transfered.
              // a is now nullptr.
              // b is now valid.
              ```

              So when assigning a `unique_ptr` the ownership is traded between them.
              Note:
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # Applying unique_ptr to Publish in ROS 2

              If applied to publishing:

              ```c++
              std::unique_ptr<std_msgs::msg::String> msg(new std_msgs::msg::String());

              msg->data = "testing";
              publisher->publish(msg);  // This is non-blocking, the message goes into a queue.
              // The user no longer has access to the message created above.
              // Instead the middleware now owns it, and this is no longer valid:
              msg->data = "testing2";  // <-- access nullptr, will cause segmentation fault.
              ```

              The benefit is that the middleware did not need to make a copy, but the user is not able to change the data they relinquished.
               - But it is not always the optimal solution, e.g. if you are reusing messages intentionally.
              Note:
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # The Subscribing Side

              What about the subscribing side of the problem? A typical example first:

              ```c++
              void callback(std_msgs::msg::String::ConstSharedPtr msg)
              {
                // msg->data = "new value"; This is illegal; the user doesn't own it.
                std_msgs::msg::String msg_copy(*msg);  // Must make a copy that the user owns.
                msg_copy = "new value";
                outgoing_publisher->publish(msg_copy);
              }
              ```

              The middleware does not give the user ownership because it may need to give the same shared message to another callback.
              - Result: the user needs to copy it explicitly in order to modify it.
              Note:
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # Using unique_ptr on the Subscribe Side

              If you use a `unique_ptr` in the callback signature, it looks like this:

              ```c++
              void callback(std_msgs::msg::String::UniquePtr msg)
              {
                msg->data = "new value";  // Edit directly; middleware relinquished ownership.
                outgoing_publisher->publish(msg);
              }
              ```

              The middleware will make a copy if there are other callbacks, so:
               - This does not avoid any extra copies, but can simplify your code if you are going to copy it anyways.
               - In one special case it can avoid a copy: if this is the only intra-process callback.
              Note:
              - Mention that in the "special" case an inter process subscriber still results in a copy.
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # Demo Cyclic Pipeline
              Note:
              Run the following command:
              - `ros2_ws/install/bin/cyclic_pipeline`
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # Demo Cyclic Pipeline

              <p style="font-size: small;">Full text: https://github.com/ros2/demos/blob/release-alpha1/intra_process_demo/src/cyclic_pipeline/cyclic_pipeline.cpp</p>
              ```c++
              struct IncrementerPipe : public rclcpp::Node
              {
                IncrementerPipe(const std::string & name, const std::string & in, const std::string & out)
                // ...
                    [this](std_msgs::msg::Int32::UniquePtr & msg) {
                      printf("Received message with value:         %d, and address: %p\n",
                        msg->data, msg.get());
                      printf("  sleeping for 1 second...\n");
                      if (!rclcpp::sleep_for(1_s)) {
                        return;  // Return if the sleep failed (e.g. on ctrl-c).
                      }
                      printf("  done.\n");
                      msg->data++;  // Increment the message's data.
                      printf("Incrementing and sending with value: %d, and address: %p\n",
                        msg->data, msg.get());
                      this->pub->publish(msg);  // Send the message along to the output topic.
                    });
                }
                // ..
              };
              ```
              Note:
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # Demo Cyclic Pipeline

              Running two instances:

              ```c++
              int main(int argc, char * argv[])
              {
                rclcpp::init(argc, argv);
                rclcpp::executors::SingleThreadedExecutor executor;

                auto pipe1 = std::make_shared<IncrementerPipe>("pipe1", "topic1", "topic2");
                auto pipe2 = std::make_shared<IncrementerPipe>("pipe2", "topic2", "topic1");
                // ..
                // Publish the first message (kicking off the cycle).
                std::unique_ptr<std_msgs::msg::Int32> msg(new std_msgs::msg::Int32());
                msg->data = 42;
                printf("Published first message with value:  %d, and address: %p\n",
                  msg->data, msg.get());
                pipe1->pub->publish(msg);

                executor.add_node(pipe1);
                executor.add_node(pipe2);
                executor.spin();
                return 0;
              }
              ```

              <p style="font-size: small;">See https://github.com/ros2/ros2/wiki/Intra-Process-Communication#the-image-pipeline-demo</p>
              Note:
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # Using unique_ptr

              So what can we say about these new ownership semantics:

              - Can help avoid copies on publish.
              - Can help avoid copies in rare cases in callbacks.
              - Can be used to create efficient pipelines, i.e. chains of 1 to 1 pub/sub.
              - Cannot rely on the published pointer to be received by callback.

              Domains where this matters:

              - Using pub/sub within a high performance perception algorithm.
               - In order to get optional introspection and modularity.
              - Systems where every `memcpy` costs battery life or latency.
               - For example in cell phones and in low latency systems.
              Note:
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # About Type Masquerading

              What I mean by Type Masquerading:
              - Publishing and Subscribing using a user-defined type, which is mapped to a ROS `.msg` type.

              This is already supported in ROS 1.
              Here is what it should look like in ROS 2 (psuedocode):

              ```c++
              struct TypeMasquerade<std_msgs::msg::String, std::string>
              {
                void to_ros(const std::string & in, std_msgs::msg::String & out) {out->data = in;}
                void from_ros(std_msgs::msg::String & in, std::string & out) {out = in->data;}
                // ... could also define serialization, move semantics, or other meta data.
              };

              void callback(std::unique_ptr<std::string> msg) {printf("%s\n", msg->c_str());}

              publisher->publish(std::unique_ptr<std::string>(new std::string("Hello World")));
              ```
              Note:
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # Incrementally Better

              In ROS 1:
              - Published `std::string` is converted to `std_msgs::msg::String`.
              - Passed around internally as `std_msgs::msg::String`.
              - Converted to `std::string` again before passing to the callback.
              - Conversions done by serializing and deserializing (not optimal).

              In ROS 2:
              - Published `std::string` is stored internally without conversion.
              - Passed around as `std::string`.
              - Converted lazily just before a callback if a different type is needed.
              - If both published and subscribed type is `std::string`, may result in zero copy/zero conversion.
              Note:
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # The Next Demo

              ```c++
              #include <opencv_ros2/type_masquerading.hpp>  // Or something similar.

              int main(...)
              {
                // ...
                  std::unique_ptr<cv::Mat> mat(new cv::Mat());
                  if (cv_capture_obj.read(*mat)) publisher->publish(mat);
                }
              }

              void callback(std::unique_ptr<cv::Mat> image) {/* image's address matches published address */};
              ```

              With this, developing your algorithm in ROS might gain you:
              - The ability to use your own types with little overhead.
              - The ability to distribute parts of the algorithm across multiple processes for fault isolation during development.
              - The ability to easily modularize and reused parts of the algorithm.
              - Optional remote introspection with minimal overhead when not in use.
              Note:
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              # What Next?

              - Make the intermediate intra-process storage smarter (intelligently convert when beneficial).
              - Consider alternative implementations of the intra-process system (internally).
              - Allow better control of memory allocation and test for real-time safety.
              - Implement Type Masquerading.
              - Building and Running a Node:
               - Remove the boilerplate, make it easy to write once then choose stand-alone versus shared process later.
              Note:
            </script>
          </section>

        </section>

<!--
        <section data-markdown data-separator-notes="^Note:">
          <script type="text/template">
            ## Deterministic startup behavior

            `We cannot present the items highlighted in red`

            - Demo
              + Starting two nodes via a launch file
              + `Exchange information after both nodes are running, not dropping the first messages`
              + `Pause, change, resume cycle using component service interface`
            - Technical background
              + Python based launch file, show flexibility and power
              + `Component life cycle`
              + `General service interface of components`

            Note:
            Planned 10 min. but since the content is much less probably only a few minutes.
          </script>
        </section>
-->

        <section>
          <section>
            <h2>DDS provides QoS &ldquo;for free&rdquo;</h2>
            <br/>

            <ul>
              <li>Industry-proven QoS strategies
                <ul>
                  <li>Extensive DDS documentation</li>
                  <li>Shared knowledge</li>
                  <li>Frees us from implementing a complex custom solution</li>
                </ul>
                <br/>
              </li>
              <li>Using UDP (instead of TCP) allows multicasting<br/><br/></li>
              <li>Support unreliable networks, e.g. drones, IoT, high latency links</li>
            </ul>

            <aside class="notes">
              End time: 17:30
            </aside>
          </section>

          <section>
            <p style="position: relative; top: -100px;">
              <img src="image/networking-spectrum.svg" alt=""/>
            </p>
            <aside class="notes">
              End time: 19:30
            </aside>

          </section>

          <section>
            <h2>Some of the QoS settings</h2>
            <br/>

            <ul style="list-style-type: none;">
              <li>ROS1: <b>UDPROS/TCPROS</b> ROS2: <b>Reliability</b>
                <ul>
                  <li><code>Best effort</code>: messages arrive &ldquo;on time&ldquo;<br/> at the expense of losing some</li>
                  <li><code>Reliable</code>: all messages must reach the other end</li>
                </ul>
              </li>
              <li>ROS1: <b>Queueing</b> ROS2: <b>History</b>
                <ul>
                  <li><code>Keep last</code>: only store <i>N</i> messages,<br/>configurable with queue depth option</li>
                  <li><code>Keep all</code>: store all messages</li>
                </ul>
              </li>
              <li>ROS1: <b>Latching</b> ROS2: <b>Durability</b>
                <ul>
                  <li><code>Volatile</code>: no persistence</li>
                  <li><code>Transient local</code>: durable data is maintained by the writer
                </ul>
              </li>
              <li>Much richer spectrum of QoS capabilities with ROS2</li>
            </ul>

            <aside class="notes">
              End time: 21:30
            </aside>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              ## Quality of Service Demo

              Note:
              Run the following commands:

              `sudo tc qdisc add dev lo root netem loss 5%` simulate lossy network.

              - Shell A: `. ros2_ws/install/setup.bash`, `export OSPL_VERBOSITY=3`, `cam2image__rmw_opensplice_cpp -r 1` publish images captured from the camera and use reliable communication
              - Shell B: `. ros2_ws/install/setup.bash`, `export OSPL_VERBOSITY=3`, `showimage__rmw_opensplice_cpp -r 1` display images from subscriber

              `sudo tc qdisc delete dev lo root netem loss 5%`

              End time 23:30
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              ## Quality of Service Demo

              Note:
              Run the following commands:

              `sudo tc qdisc add dev lo root netem loss 5%` simulate lossy network.

              - Shell A: `. ros2_ws/install/setup.bash`, `export OSPL_VERBOSITY=3`, `cam2image__rmw_opensplice_cpp -r 0` publish images captured from the camera and use best effort reliability
              - Shell B: `. ros2_ws/install/setup.bash`, `export OSPL_VERBOSITY=3`, `showimage__rmw_opensplice_cpp -r 0` display images from subscriber

              `sudo tc qdisc delete dev lo root netem loss 5%`

              End time 25:30
            </script>
          </section>

          <section>
            <h2>QoS profiles</h2>

            <pre><code class="cpp" data-trim>
typedef struct RMW_PUBLIC_TYPE rmw_qos_profile_t
{
  enum rmw_qos_history_policy_t history;
  size_t depth;
  enum rmw_qos_reliability_policy_t reliability;
  enum rmw_qos_durability_policy_t durability;
} rmw_qos_profile_t;
            </code></pre>
            <br/>

            <div class="row">
              <div class="col-md-4">
                <ul style="list-style-type: none; padding-left: 0;">
                  <li><b>Predefined profiles</b>
                    <ul>
                      <li>sensor data</li>
                      <li>services</li>
                      <li>parameters</li>
                    </ul>
                  </li>
                </ul>
              </div>
              <div class="col-md-8">
                <ul style="list-style-type: none; margin-left: 0; padding-left: 0;">
                  <li><b>Integration with existing DDS deployments</b>
                    <ul>
                      <li>every policy has a &ldquo;system default&ldquo; option</li>
                      <li>optionally use DDS vendor tools<br/>to define QoS settings and profiles</li>
                      <li>do not disrupt existing DDS deployments</li>
                    </ul>
                  </li>
                </ul>
              </div>
            </div>

            <aside class="notes">
              End time: 27:00
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Bridging between ROS versions</h2>
            <br/>
            <div class="row">
              <div class="col-md-6">
                <b>ROS 2</b><br/>
                <ul>
                  <li>New features</li>
                  <li>Superior communication</li>
                </ul>
              </div>
              <div class="col-md-6">
                <b>ROS 1</b><br/>
                <ul>
                  <li>Plenty of tools</li>
                  <li>Existing funtionality</li>
                </ul>
              </div>
            </div>
            <br/>
            <br/>
            <svg id="publisher-subscriber" width="85%" height="80">
              <marker id="publisher-subscriber_start-triangle" viewBox="0 0 10 10" refX="0" refY="5" markerUnits="strokeWidth" markerWidth="10" markerHeight="7" orient="auto">
                <path d="M 10 0 L 0 5 L 10 10 z"/>
              </marker>
              <marker id="publisher-subscriber_end-triangle" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="10" markerHeight="7" orient="auto">
                <path d="M 0 0 L 10 5 L 0 10 z"/>
              </marker>
              <g title="ROS 2 node">
                <ellipse cx="20%" cy="40" rx="15%" ry="36"/>
                <text x="20%" y="48" text-anchor="middle">node</text>
              </g>
              <g title="ROS 1 node">
                <ellipse cx="80%" cy="40" rx="15%" ry="36"/>
                <text x="80%" y="48" text-anchor="middle">node</text>
              </g>
              <g title="communication">
                <line x1="35%" y1="40" x2="65%" y2="40" marker-start="url(#publisher-subscriber_start-triangle)" marker-end="url(#publisher-subscriber_end-triangle)" stroke-dasharray="5,5"/>
                <text x="50%" y="32" text-anchor="middle" stroke="#353535">?</text>
              </g>
            </svg>

            <aside class="notes">
              End time: 26:00
            </aside>
          </section>

          <section>
            <h2>Dynamic Bridge</h2>
            <br/>
            <br/>
            <svg id="dynamic-bridge" width="860" height="340">
              <marker id="dynamic_bridge_start-triangle" viewBox="0 0 10 10" refX="0" refY="5" markerUnits="strokeWidth" markerWidth="10" markerHeight="7" orient="auto">
                <path d="M 10 0 L 0 5 L 10 10 z"/>
              </marker>
              <marker id="dynamic_bridge_end-triangle" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="10" markerHeight="7" orient="auto">
                <path d="M 0 0 L 10 5 L 0 10 z"/>
              </marker>
              <marker id="dynamic_bridge_end-triangle-red" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="10" markerHeight="7" orient="auto">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#c7254e"/>
              </marker>
              <line x1="50%" y1="0" x2="50%" y2="100%" style="stroke: #cccccc;" stroke-dasharray="5,5"/>
              <g title="ROS 2 publisher with topic">
                <ellipse cx="140" cy="40" rx="130" ry="30"/>
                <text x="140" y="49" text-anchor="middle">ROS 2 publisher</text>
                <polyline points="140,70 140,120 235,120" marker-end="url(#dynamic_bridge_end-triangle)"/>
                <rect x="235" y="100" width="100" height="40"/>
                <text x="285" y="130" text-anchor="middle">image</text>
              </g>
              <g title="ROS 1 subscriber with topic">
                <ellipse cx="720" cy="40" rx="130" ry="30"/>
                <text x="720" y="49" text-anchor="middle">ROS 1 subscriber</text>
                <polyline points="625,120 720,120 720,70" marker-end="url(#dynamic_bridge_end-triangle)"/>
                <rect x="525" y="100" width="100" height="40"/>
                <text x="575" y="130" text-anchor="middle">image</text>
              </g>
              <g title="bridge" class="fragment">
                <ellipse cx="430" cy="200" rx="80" ry="30" style="fill: white;"/>
                <text x="430" y="208" text-anchor="middle">bridge</text>
              </g>
              <g title="topic introspection" class="fragment current-visible">
                <path d="M 400 230 Q 200 300 260 140" style="stroke: #c7254e;" marker-end="url(#dynamic_bridge_end-triangle-red)"/>
                <path d="M 460 230 Q 660 300 600 140" style="stroke: #c7254e;" marker-end="url(#dynamic_bridge_end-triangle-red)"/>
                <text x="50%" y="280" text-anchor="middle" style="fill: #c7254e; stroke: #c7254e;">check available topics:</text>
                <text x="50%" y="320" text-anchor="middle" style="fill: #c7254e; stroke: #c7254e;">get topic name and topic type</text>
              </g>
              <g title="dynamic connection" class="fragment">
                <polyline points="285,140 285,200 350,200" marker-end="url(#dynamic_bridge_end-triangle)"/>
                <polyline points="510,200 575,200 575,140" marker-end="url(#dynamic_bridge_end-triangle)"/>
              </g>
            </svg>

            <aside class="notes">
              End time: 27:30
            </aside>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              ## Bridge Demo

              Note:
              Run the following commands:
              - Shell A: `. /opt/ros/indigo/setup.bash`, `roscore`
              - Shell B: `. ros2_ws/install/setup.bash`, `export ROS_MASTER_URI=http://localhost:11311`, `dynamic_bridge`
              - Shell C: `. /opt/ros/indigo/setup.bash`, `rosrun usb_cam usb_cam_node usb_cam/image_raw:=image` publishing images
              - Shell D: `. /opt/ros/indigo/setup.bash`, `rqt` perspective with image view and publisher plugin
              - Show incoming ROS 1 images.
              - Shell C: Ctrl-C
              - Show "frozen" last image.
              - Shell E: `. ros2_ws/install/setup.bash`, `cam2image` publishing images
              - Show console of shell B.
              - Show incoming ROS 2 images.
              - Trigger flipping.
              - Show incoming flipped ROS 2 images.

              End time 29:15
            </script>
          </section>

          <section data-markdown data-separator-notes="^Note:">
            <script type="text/template">
              ## Technical background

              - Currently implemented in C++
              - Find all message definitions
                + in ROS 1 using the `rosmsg` API (crawls the FS &#9785;)
                + in ROS 2 using the `ament resource index` [](https://github.com/ament/ament_cmake/blob/master/ament_cmake_core/doc/resource_index.md)<!-- .element: class="glyphicon glyphicon-file" --> (no crawling &#128526;)
              - Generate mappings between ROS 1 types and ROS 2 types
                + automatic rules
                + optionally: custom rules (specified in a `.yaml` file)
                + &forall; type pairs
                  * register at a factory
                  * generate conversion functions (ROS 1 &harr; ROS 2)
              - Build the bridge
                + use `roscpp` found via `pkg-config`
                + use `rclcpp` found via `CMake find_package()`
              - `Challenge`: all header files must be non-colliding (!)

              Note:
              End time 30:45
            </script>
          </section>
        </section>

        <section data-markdown data-separator-notes="^Note:">
          <script type="text/template">
            ## Roadmap

            - First release (`Alpha 1`) was on Sep. 1st
              + https://github.com/ros2/ros2/wiki/Alpha1-Overview
            - Upcoming features, grouped and ordered <!-- .element: class="fragment" data-fragment-index="1" -->
              + https://github.com/ros2/ros2/wiki/Roadmap <!-- .element: class="fragment" data-fragment-index="1" -->
            - Current work items for <!-- .element: class="fragment" data-fragment-index="2" -->
              `Alpha 2` <!-- .element: class="fragment" data-fragment-index="2" -->
              + Component life cycle <!-- .element: class="fragment" data-fragment-index="2" -->
                * Introspection and orchestration APIs <!-- .element: class="fragment" data-fragment-index="2" -->
                * Using `class_loader` / `pluginlib` <!-- .element: class="fragment" data-fragment-index="2" -->
              + Launch system <!-- .element: class="fragment" data-fragment-index="2" -->
                * Using life cycle and orchestration <!-- .element: class="fragment" data-fragment-index="2" -->
              + Continue work on ROS client libraries <!-- .element: class="fragment" data-fragment-index="2" -->
                * Solve technical challenges in C++ <!-- .element: class="fragment" data-fragment-index="2" -->
                * C as well as Python API <!-- .element: class="fragment" data-fragment-index="2" -->

            Note:
            End time 32:00
          </script>
        </section>

        <section data-markdown data-separator-notes="^Note:">
          <script type="text/template">
            ## Related presentations

            - **ROS 2 on "small" embedded systems**
              + already presented in the morning by *Morgan*
            - **Real-time Performance in ROS 2**
              + upcoming presentation from *Jackie* and *Adolfo*

            Note:
            End time 32:30
          </script>
        </section>

        <section>
          <h2 style="text-align: left;">Questions...</h2>
          <br/>
          <br/>
          <br/>
          <p style="text-align: right;">
            For more information go to:<br/>
            <a href="http://www.ros2.org">www.ros2.org</a>
          </p>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        slideNumber: true,
        history: true,
        transition: 'convex',
        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
      var previous_index_h = 0;
      var previous_index_v = 0;
      Reveal.addEventListener( 'slidechanged', function(event) {
        if (event.previousSlide) {
          if (event.indexh > previous_index_h) {
            document.getElementById('osrf-logo-clockwise').beginElement();
          } else if (event.indexh < previous_index_h) {
            document.getElementById('osrf-logo-counterclockwise').beginElement();
          } else if (event.indexv > previous_index_v) {
            document.getElementById('osrf-logo-clockwise').beginElement();
          } else if (event.indexv < previous_index_v) {
            document.getElementById('osrf-logo-counterclockwise').beginElement();
          }
        }
        previous_index_h = event.indexh;
        previous_index_v = event.indexv;
      });
      Reveal.addEventListener('fragmentshown', function(event) {
        document.getElementById('osrf-logo-flash').beginElement();
      });
      Reveal.addEventListener('fragmenthidden', function(event) {
        document.getElementById('osrf-logo-flash').beginElement();
      });
    </script>
  </body>
</html>
